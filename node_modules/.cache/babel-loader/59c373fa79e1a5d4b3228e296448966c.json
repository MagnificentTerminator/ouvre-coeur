{"ast":null,"code":";\n(function () {\n  'use strict';\n\n  var root = this;\n  var has_require = typeof require !== 'undefined';\n\n  var THREE = root.THREE || has_require && require('three');\n\n  if (!THREE) throw new Error('MeshLine requires three.js');\n\n  function MeshLine() {\n    THREE.BufferGeometry.call(this);\n    this.type = 'MeshLine';\n    this.positions = [];\n    this.previous = [];\n    this.next = [];\n    this.side = [];\n    this.width = [];\n    this.indices_array = [];\n    this.uvs = [];\n    this.counters = [];\n    this._vertices = [];\n    this._bufferArray = [];\n    this.widthCallback = null; // Used to raycast\n\n    this.matrixWorld = new THREE.Matrix4(); // to support previous api\n\n    Object.defineProperties(this, {\n      geometry: {\n        enumerable: true,\n        get: function get() {\n          return this;\n        },\n        set: function set(value) {\n          this.setFromGeometry(value);\n        }\n      },\n      vertices: {\n        enumerable: true,\n        get: function get() {\n          return this._vertices;\n        },\n        set: function set(value) {\n          this.setVertices(value);\n        }\n      },\n      bufferArray: {\n        enumerable: true,\n        get: function get() {\n          return this._bufferArray;\n        },\n        set: function set(value) {\n          this.setBufferArray(value);\n        }\n      }\n    });\n  }\n\n  MeshLine.prototype = Object.create(THREE.BufferGeometry.prototype);\n  MeshLine.prototype.constructor = MeshLine;\n  MeshLine.prototype.isMeshLine = true;\n\n  MeshLine.prototype.setMatrixWorld = function (matrixWorld) {\n    this.matrixWorld = matrixWorld;\n  };\n\n  MeshLine.prototype.setFromGeometry = function (g, c) {\n    if (g instanceof THREE.Geometry) {\n      this.setVertices(g.vertices, c);\n    }\n\n    if (g instanceof THREE.BufferGeometry) {\n      this.setBufferArray(g.getAttribute('position').array, c);\n    }\n\n    if (g instanceof Float32Array || g instanceof Array) {\n      // to support previous api\n      this.setBufferArray(g, c);\n    }\n  }; // to support previous api\n\n\n  MeshLine.prototype.setGeometry = function (g, c) {\n    this.setFromGeometry(g, c);\n  };\n\n  MeshLine.prototype.setVertices = function (vts, wcb) {\n    this._vertices = vts;\n    this.widthCallback = wcb || this.widthCallback;\n    this.positions = [];\n    this.counters = [];\n\n    for (var j = 0; j < vts.length; j++) {\n      var v = vts[j];\n      var c = j / vts.length;\n      this.positions.push(v.x, v.y, v.z);\n      this.positions.push(v.x, v.y, v.z);\n      this.counters.push(c);\n      this.counters.push(c);\n    }\n\n    this.process();\n  };\n\n  MeshLine.prototype.setBufferArray = function (ba, wcb) {\n    this._bufferArray = ba;\n    this.widthCallback = wcb || this.widthCallback;\n    this.positions = [];\n    this.counters = [];\n\n    for (var j = 0; j < ba.length; j += 3) {\n      var c = j / ba.length;\n      this.positions.push(ba[j], ba[j + 1], ba[j + 2]);\n      this.positions.push(ba[j], ba[j + 1], ba[j + 2]);\n      this.counters.push(c);\n      this.counters.push(c);\n    }\n\n    this.process();\n  };\n\n  function MeshLineRaycast(raycaster, intersects) {\n    var inverseMatrix = new THREE.Matrix4();\n    var ray = new THREE.Ray();\n    var sphere = new THREE.Sphere();\n    var interRay = new THREE.Vector3();\n    var geometry = this.geometry; // Checking boundingSphere distance to ray\n\n    sphere.copy(geometry.boundingSphere);\n    sphere.applyMatrix4(this.matrixWorld);\n\n    if (raycaster.ray.intersectSphere(sphere, interRay) === false) {\n      return;\n    }\n\n    inverseMatrix.getInverse(this.matrixWorld);\n    ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);\n    var vStart = new THREE.Vector3();\n    var vEnd = new THREE.Vector3();\n    var interSegment = new THREE.Vector3();\n    var step = this instanceof THREE.LineSegments ? 2 : 1;\n    var index = geometry.index;\n    var attributes = geometry.attributes;\n\n    if (index !== null) {\n      var indices = index.array;\n      var positions = attributes.position.array;\n      var widths = attributes.width.array;\n\n      for (var i = 0, l = indices.length - 1; i < l; i += step) {\n        var a = indices[i];\n        var b = indices[i + 1];\n        vStart.fromArray(positions, a * 3);\n        vEnd.fromArray(positions, b * 3);\n        var width = widths[Math.floor(i / 3)] != undefined ? widths[Math.floor(i / 3)] : 1;\n        var precision = raycaster.linePrecision + this.material.lineWidth * width / 2;\n        var precisionSq = precision * precision;\n        var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);\n        if (distSq > precisionSq) continue;\n        interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation\n\n        var distance = raycaster.ray.origin.distanceTo(interRay);\n        if (distance < raycaster.near || distance > raycaster.far) continue;\n        intersects.push({\n          distance: distance,\n          // What do we want? intersection point on the ray or on the segment??\n          // point: raycaster.ray.at( distance ),\n          point: interSegment.clone().applyMatrix4(this.matrixWorld),\n          index: i,\n          face: null,\n          faceIndex: null,\n          object: this\n        }); // make event only fire once\n\n        i = l;\n      }\n    }\n  }\n\n  MeshLine.prototype.raycast = MeshLineRaycast;\n\n  MeshLine.prototype.compareV3 = function (a, b) {\n    var aa = a * 6;\n    var ab = b * 6;\n    return this.positions[aa] === this.positions[ab] && this.positions[aa + 1] === this.positions[ab + 1] && this.positions[aa + 2] === this.positions[ab + 2];\n  };\n\n  MeshLine.prototype.copyV3 = function (a) {\n    var aa = a * 6;\n    return [this.positions[aa], this.positions[aa + 1], this.positions[aa + 2]];\n  };\n\n  MeshLine.prototype.process = function () {\n    var l = this.positions.length / 6;\n    this.previous = [];\n    this.next = [];\n    this.side = [];\n    this.width = [];\n    this.indices_array = [];\n    this.uvs = [];\n    var w;\n    var v; // initial previous points\n\n    if (this.compareV3(0, l - 1)) {\n      v = this.copyV3(l - 2);\n    } else {\n      v = this.copyV3(0);\n    }\n\n    this.previous.push(v[0], v[1], v[2]);\n    this.previous.push(v[0], v[1], v[2]);\n\n    for (var j = 0; j < l; j++) {\n      // sides\n      this.side.push(1);\n      this.side.push(-1); // widths\n\n      if (this.widthCallback) w = this.widthCallback(j / (l - 1));else w = 1;\n      this.width.push(w);\n      this.width.push(w); // uvs\n\n      this.uvs.push(j / (l - 1), 0);\n      this.uvs.push(j / (l - 1), 1);\n\n      if (j < l - 1) {\n        // points previous to poisitions\n        v = this.copyV3(j);\n        this.previous.push(v[0], v[1], v[2]);\n        this.previous.push(v[0], v[1], v[2]); // indices\n\n        var n = j * 2;\n        this.indices_array.push(n, n + 1, n + 2);\n        this.indices_array.push(n + 2, n + 1, n + 3);\n      }\n\n      if (j > 0) {\n        // points after poisitions\n        v = this.copyV3(j);\n        this.next.push(v[0], v[1], v[2]);\n        this.next.push(v[0], v[1], v[2]);\n      }\n    } // last next point\n\n\n    if (this.compareV3(l - 1, 0)) {\n      v = this.copyV3(1);\n    } else {\n      v = this.copyV3(l - 1);\n    }\n\n    this.next.push(v[0], v[1], v[2]);\n    this.next.push(v[0], v[1], v[2]); // redefining the attribute seems to prevent range errors \n    // if the user sets a differing number of vertices\n\n    if (!this._attributes || this._attributes.position.count !== this.positions.length) {\n      this._attributes = {\n        position: new THREE.BufferAttribute(new Float32Array(this.positions), 3),\n        previous: new THREE.BufferAttribute(new Float32Array(this.previous), 3),\n        next: new THREE.BufferAttribute(new Float32Array(this.next), 3),\n        side: new THREE.BufferAttribute(new Float32Array(this.side), 1),\n        width: new THREE.BufferAttribute(new Float32Array(this.width), 1),\n        uv: new THREE.BufferAttribute(new Float32Array(this.uvs), 2),\n        index: new THREE.BufferAttribute(new Uint16Array(this.indices_array), 1),\n        counters: new THREE.BufferAttribute(new Float32Array(this.counters), 1)\n      };\n    } else {\n      this._attributes.position.copyArray(new Float32Array(this.positions));\n\n      this._attributes.position.needsUpdate = true;\n\n      this._attributes.previous.copyArray(new Float32Array(this.previous));\n\n      this._attributes.previous.needsUpdate = true;\n\n      this._attributes.next.copyArray(new Float32Array(this.next));\n\n      this._attributes.next.needsUpdate = true;\n\n      this._attributes.side.copyArray(new Float32Array(this.side));\n\n      this._attributes.side.needsUpdate = true;\n\n      this._attributes.width.copyArray(new Float32Array(this.width));\n\n      this._attributes.width.needsUpdate = true;\n\n      this._attributes.uv.copyArray(new Float32Array(this.uvs));\n\n      this._attributes.uv.needsUpdate = true;\n\n      this._attributes.index.copyArray(new Uint16Array(this.indices_array));\n\n      this._attributes.index.needsUpdate = true;\n    }\n\n    this.setAttribute('position', this._attributes.position);\n    this.setAttribute('previous', this._attributes.previous);\n    this.setAttribute('next', this._attributes.next);\n    this.setAttribute('side', this._attributes.side);\n    this.setAttribute('width', this._attributes.width);\n    this.setAttribute('uv', this._attributes.uv);\n    this.setAttribute('counters', this._attributes.counters);\n    this.setIndex(this._attributes.index);\n    this.computeBoundingSphere();\n    this.computeBoundingBox();\n  };\n\n  function memcpy(src, srcOffset, dst, dstOffset, length) {\n    var i;\n    src = src.subarray || src.slice ? src : src.buffer;\n    dst = dst.subarray || dst.slice ? dst : dst.buffer;\n    src = srcOffset ? src.subarray ? src.subarray(srcOffset, length && srcOffset + length) : src.slice(srcOffset, length && srcOffset + length) : src;\n\n    if (dst.set) {\n      dst.set(src, dstOffset);\n    } else {\n      for (i = 0; i < src.length; i++) {\n        dst[i + dstOffset] = src[i];\n      }\n    }\n\n    return dst;\n  }\n  /**\n   * Fast method to advance the line by one position.  The oldest position is removed.\n   * @param position\n   */\n\n\n  MeshLine.prototype.advance = function (position) {\n    var positions = this._attributes.position.array;\n    var previous = this._attributes.previous.array;\n    var next = this._attributes.next.array;\n    var l = positions.length; // PREVIOUS\n\n    memcpy(positions, 0, previous, 0, l); // POSITIONS\n\n    memcpy(positions, 6, positions, 0, l - 6);\n    positions[l - 6] = position.x;\n    positions[l - 5] = position.y;\n    positions[l - 4] = position.z;\n    positions[l - 3] = position.x;\n    positions[l - 2] = position.y;\n    positions[l - 1] = position.z; // NEXT\n\n    memcpy(positions, 6, next, 0, l - 6);\n    next[l - 6] = position.x;\n    next[l - 5] = position.y;\n    next[l - 4] = position.z;\n    next[l - 3] = position.x;\n    next[l - 2] = position.y;\n    next[l - 1] = position.z;\n    this._attributes.position.needsUpdate = true;\n    this._attributes.previous.needsUpdate = true;\n    this._attributes.next.needsUpdate = true;\n  };\n\n  THREE.ShaderChunk['meshline_vert'] = ['', THREE.ShaderChunk.logdepthbuf_pars_vertex, THREE.ShaderChunk.fog_pars_vertex, '', 'attribute vec3 previous;', 'attribute vec3 next;', 'attribute float side;', 'attribute float width;', 'attribute float counters;', '', 'uniform vec2 resolution;', 'uniform float lineWidth;', 'uniform vec3 color;', 'uniform float opacity;', 'uniform float near;', 'uniform float far;', 'uniform float sizeAttenuation;', '', 'varying vec2 vUV;', 'varying vec4 vColor;', 'varying float vCounters;', '', 'vec2 fix( vec4 i, float aspect ) {', '', '    vec2 res = i.xy / i.w;', '    res.x *= aspect;', '\t vCounters = counters;', '    return res;', '', '}', '', 'void main() {', '', '    float aspect = resolution.x / resolution.y;', '', '    vColor = vec4( color, opacity );', '    vUV = uv;', '', '    mat4 m = projectionMatrix * modelViewMatrix;', '    vec4 finalPosition = m * vec4( position, 1.0 );', '    vec4 prevPos = m * vec4( previous, 1.0 );', '    vec4 nextPos = m * vec4( next, 1.0 );', '', '    vec2 currentP = fix( finalPosition, aspect );', '    vec2 prevP = fix( prevPos, aspect );', '    vec2 nextP = fix( nextPos, aspect );', '', '    float w = lineWidth * width;', '', '    vec2 dir;', '    if( nextP == currentP ) dir = normalize( currentP - prevP );', '    else if( prevP == currentP ) dir = normalize( nextP - currentP );', '    else {', '        vec2 dir1 = normalize( currentP - prevP );', '        vec2 dir2 = normalize( nextP - currentP );', '        dir = normalize( dir1 + dir2 );', '', '        vec2 perp = vec2( -dir1.y, dir1.x );', '        vec2 miter = vec2( -dir.y, dir.x );', '        //w = clamp( w / dot( miter, perp ), 0., 4. * lineWidth * width );', '', '    }', '', '    //vec2 normal = ( cross( vec3( dir, 0. ), vec3( 0., 0., 1. ) ) ).xy;', '    vec4 normal = vec4( -dir.y, dir.x, 0., 1. );', '    normal.xy *= .5 * w;', '    normal *= projectionMatrix;', '    if( sizeAttenuation == 0. ) {', '        normal.xy *= finalPosition.w;', '        normal.xy /= ( vec4( resolution, 0., 1. ) * projectionMatrix ).xy;', '    }', '', '    vec4 offset = vec4( normal.xy * side, 0.0, 1.0 );', '    finalPosition.xy += offset.xy;', '', '    gl_Position = finalPosition;', '', THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.fog_vertex && '    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );', THREE.ShaderChunk.fog_vertex, '}'].join('\\r\\n');\n  THREE.ShaderChunk['meshline_frag'] = ['', THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, '', 'uniform sampler2D map;', 'uniform sampler2D alphaMap;', 'uniform float useMap;', 'uniform float useAlphaMap;', 'uniform float useDash;', 'uniform float dashArray;', 'uniform float dashOffset;', 'uniform float dashRatio;', 'uniform float visibility;', 'uniform float alphaTest;', 'uniform vec2 repeat;', '', 'varying vec2 vUV;', 'varying vec4 vColor;', 'varying float vCounters;', '', 'void main() {', '', THREE.ShaderChunk.logdepthbuf_fragment, '', '    vec4 c = vColor;', '    if( useMap == 1. ) c *= texture2D( map, vUV * repeat );', '    if( useAlphaMap == 1. ) c.a *= texture2D( alphaMap, vUV * repeat ).a;', '    if( c.a < alphaTest ) discard;', '    if( useDash == 1. ){', '        c.a *= ceil(mod(vCounters + dashOffset, dashArray) - (dashArray * dashRatio));', '    }', '    gl_FragColor = c;', '    gl_FragColor.a *= step(vCounters, visibility);', '', THREE.ShaderChunk.fog_fragment, '}'].join('\\r\\n');\n\n  function MeshLineMaterial(parameters) {\n    THREE.ShaderMaterial.call(this, {\n      uniforms: Object.assign({}, THREE.UniformsLib.fog, {\n        lineWidth: {\n          value: 1\n        },\n        map: {\n          value: null\n        },\n        useMap: {\n          value: 0\n        },\n        alphaMap: {\n          value: null\n        },\n        useAlphaMap: {\n          value: 0\n        },\n        color: {\n          value: new THREE.Color(0xffffff)\n        },\n        opacity: {\n          value: 1\n        },\n        resolution: {\n          value: new THREE.Vector2(1, 1)\n        },\n        sizeAttenuation: {\n          value: 1\n        },\n        near: {\n          value: 1\n        },\n        far: {\n          value: 1\n        },\n        dashArray: {\n          value: 0\n        },\n        dashOffset: {\n          value: 0\n        },\n        dashRatio: {\n          value: 0.5\n        },\n        useDash: {\n          value: 0\n        },\n        visibility: {\n          value: 1\n        },\n        alphaTest: {\n          value: 0\n        },\n        repeat: {\n          value: new THREE.Vector2(1, 1)\n        }\n      }),\n      vertexShader: THREE.ShaderChunk.meshline_vert,\n      fragmentShader: THREE.ShaderChunk.meshline_frag\n    });\n    this.type = 'MeshLineMaterial';\n    Object.defineProperties(this, {\n      lineWidth: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.lineWidth.value;\n        },\n        set: function set(value) {\n          this.uniforms.lineWidth.value = value;\n        }\n      },\n      map: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.map.value;\n        },\n        set: function set(value) {\n          this.uniforms.map.value = value;\n        }\n      },\n      useMap: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.useMap.value;\n        },\n        set: function set(value) {\n          this.uniforms.useMap.value = value;\n        }\n      },\n      alphaMap: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.alphaMap.value;\n        },\n        set: function set(value) {\n          this.uniforms.alphaMap.value = value;\n        }\n      },\n      useAlphaMap: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.useAlphaMap.value;\n        },\n        set: function set(value) {\n          this.uniforms.useAlphaMap.value = value;\n        }\n      },\n      color: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.color.value;\n        },\n        set: function set(value) {\n          this.uniforms.color.value = value;\n        }\n      },\n      opacity: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.opacity.value;\n        },\n        set: function set(value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      resolution: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.resolution.value;\n        },\n        set: function set(value) {\n          this.uniforms.resolution.value.copy(value);\n        }\n      },\n      sizeAttenuation: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.sizeAttenuation.value;\n        },\n        set: function set(value) {\n          this.uniforms.sizeAttenuation.value = value;\n        }\n      },\n      near: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.near.value;\n        },\n        set: function set(value) {\n          this.uniforms.near.value = value;\n        }\n      },\n      far: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.far.value;\n        },\n        set: function set(value) {\n          this.uniforms.far.value = value;\n        }\n      },\n      dashArray: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.dashArray.value;\n        },\n        set: function set(value) {\n          this.uniforms.dashArray.value = value;\n          this.useDash = value !== 0 ? 1 : 0;\n        }\n      },\n      dashOffset: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.dashOffset.value;\n        },\n        set: function set(value) {\n          this.uniforms.dashOffset.value = value;\n        }\n      },\n      dashRatio: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.dashRatio.value;\n        },\n        set: function set(value) {\n          this.uniforms.dashRatio.value = value;\n        }\n      },\n      useDash: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.useDash.value;\n        },\n        set: function set(value) {\n          this.uniforms.useDash.value = value;\n        }\n      },\n      visibility: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.visibility.value;\n        },\n        set: function set(value) {\n          this.uniforms.visibility.value = value;\n        }\n      },\n      alphaTest: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.alphaTest.value;\n        },\n        set: function set(value) {\n          this.uniforms.alphaTest.value = value;\n        }\n      },\n      repeat: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.repeat.value;\n        },\n        set: function set(value) {\n          this.uniforms.repeat.value.copy(value);\n        }\n      }\n    });\n    this.setValues(parameters);\n  }\n\n  MeshLineMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);\n  MeshLineMaterial.prototype.constructor = MeshLineMaterial;\n  MeshLineMaterial.prototype.isMeshLineMaterial = true;\n\n  MeshLineMaterial.prototype.copy = function (source) {\n    THREE.ShaderMaterial.prototype.copy.call(this, source);\n    this.lineWidth = source.lineWidth;\n    this.map = source.map;\n    this.useMap = source.useMap;\n    this.alphaMap = source.alphaMap;\n    this.useAlphaMap = source.useAlphaMap;\n    this.color.copy(source.color);\n    this.opacity = source.opacity;\n    this.resolution.copy(source.resolution);\n    this.sizeAttenuation = source.sizeAttenuation;\n    this.near = source.near;\n    this.far = source.far;\n    this.dashArray.copy(source.dashArray);\n    this.dashOffset.copy(source.dashOffset);\n    this.dashRatio.copy(source.dashRatio);\n    this.useDash = source.useDash;\n    this.visibility = source.visibility;\n    this.alphaTest = source.alphaTest;\n    this.repeat.copy(source.repeat);\n    return this;\n  };\n\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = {\n        MeshLine: MeshLine,\n        MeshLineMaterial: MeshLineMaterial,\n        MeshLineRaycast: MeshLineRaycast\n      };\n    }\n\n    exports.MeshLine = MeshLine;\n    exports.MeshLineMaterial = MeshLineMaterial;\n    exports.MeshLineRaycast = MeshLineRaycast;\n  } else {\n    root.MeshLine = MeshLine;\n    root.MeshLineMaterial = MeshLineMaterial;\n    root.MeshLineRaycast = MeshLineRaycast;\n  }\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}